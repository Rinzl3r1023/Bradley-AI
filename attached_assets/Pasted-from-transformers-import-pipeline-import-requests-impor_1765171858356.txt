from transformers import pipeline
import requests
import urllib.parse
import socket
import ipaddress
import logging
import os

logging.basicConfig(level=logging.INFO)

# Same security constants as video detector
ALLOWED_DOMAINS = ['huggingface.co', 'cdn.huggingface.co']
ALLOWED_SCHEMES = ['https']
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB

def is_private_ip(ip_str: str) -> bool:
    try:
        ip = ipaddress.ip_address(ip_str.strip('[]'))
        return (
            ip.is_private or
            ip.is_loopback or
            ip.is_link_local or
            ip.is_reserved or
            ip.is_multicast or
            ip.is_unspecified or
            ipaddress.ip_network('100.64.0.0/10').overlaps(ipaddress.ip_network(f'{ip}/32'))
        )
    except ValueError:
        return False

def safe_request(url: str):
    parsed = urllib.parse.urlparse(url)
    try:
        ip = socket.gethostbyname(parsed.hostname)
        if is_private_ip(ip):
            raise ValueError("Resolves to private IP")
    except socket.gaierror:
        raise ValueError("Invalid hostname")
    
    response = requests.get(url, timeout=(5, 15), stream=True, allow_redirects=False)
    if response.is_redirect:
        redirect_url = response.headers.get('Location')
        if redirect_url:
            safe_request(redirect_url)
    
    content = bytearray()
    for chunk in response.iter_content(chunk_size=8192):
        content.extend(chunk)
        if len(content) > MAX_FILE_SIZE:
            raise ValueError("File exceeded size limit during download")
    
    return content

def detect_audio_deepfake(url_or_path):
    try:
        if url_or_path.startswith("http"):
            content = safe_request(url_or_path)
            # Save temporarily for pipeline
            temp_path = "temp_audio.wav"
            with open(temp_path, "wb") as f:
                f.write(content)
            audio_input = temp_path
        else:
            real_path = os.path.realpath(url_or_path)
            if not real_path.startswith(os.path.realpath(os.getcwd() + os.sep)):
                raise ValueError("Path outside allowed directory")
            if not os.path.isfile(real_path):
                raise ValueError("File not found")
            audio_input = real_path
        
        # Real voice clone / synthetic speech detector
        voice_detector = pipeline("audio-classification", 
                                model="speechbrain/lang-id-voxlingua107-epaca-tdnn")
        result = voice_detector(audio_input)
        
        # Extract synthetic score (model labels synthetic speech)
        synth_score = next((x['score'] for x in result if x['label'] == 'synthetic'), 0.0)
        is_fake = synth_score > 0.65
        
        # Clean up temp file if created
        if url_or_path.startswith("http") and os.path.exists(temp_path):
            os.remove(temp_path)
        
        return {
            "is_deepfake": is_fake,
            "confidence": round(synth_score, 3),
            "label": "FAKE" if is_fake else "REAL"
        }
    except ValueError as e:
        logging.error(f"Validation error: {e}")
        return {"error": str(e), "is_deepfake": False, "confidence": 0.0}
    except Exception as e:
        logging.critical(f"Unexpected error: {e}")
        return {"error": "Processing failed", "is_deepfake": False, "confidence": 0.0}