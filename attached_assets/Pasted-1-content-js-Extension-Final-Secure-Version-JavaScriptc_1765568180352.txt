1. content.js (Extension — Final Secure Version)
JavaScriptconst CONFIG = {
  API_BASE: 'https://bradleyai.replit.app',
  SCAN_INTERVAL: 30000,
  CONFIDENCE_THRESHOLD: 0.85,
  MAX_RETRIES: 2,
  REQUEST_TIMEOUT: 15000,
  RATE_LIMIT_WINDOW: 60000,
  RATE_LIMIT_MAX: 20
};

class ExtensionState {
  constructor() {
    this.isEnabled = true;
    this.hasConsent = false;
    this.scanQueue = [];
    this.isScanning = false;
    this.scannedUrls = new Set();
    this.rateLimitCounter = [];
  }
  async initialize() {
    const data = await chrome.storage.sync.get(['enabled', 'hasConsent']);
    this.isEnabled = data.enabled !== false;
    this.hasConsent = data.hasConsent === true;
    if (!this.hasConsent) this.showConsentDialog();
  }
  isRateLimited() {
    const now = Date.now();
    this.rateLimitCounter = this.rateLimitCounter.filter(t => now - t < CONFIG.RATE_LIMIT_WINDOW);
    return this.rateLimitCounter.length >= CONFIG.RATE_LIMIT_MAX;
  }
  recordRequest() { this.rateLimitCounter.push(Date.now()); }
  showConsentDialog() { new ConsentDialog().show(accepted => {
    this.hasConsent = accepted;
    chrome.storage.sync.set({ hasConsent: accepted });
    if (accepted) scanner.scan();
  }); }
}

const state = new ExtensionState();

class URLValidator {
  static ALLOWED_PROTOCOLS = ['https:'];
  static BLOCKED_PATTERNS = [
    /^(localhost|127\.0\.0\.1|0\.0\.0\.0|192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.)/i,
    /\.(local|internal|corp)$/i
  ];
  static isValid(urlString) {
    try {
      const url = new URL(urlString);
      if (!this.ALLOWED_PROTOCOLS.includes(url.protocol)) return false;
      for (const pattern of this.BLOCKED_PATTERNS) {
        if (pattern.test(url.hostname)) return false;
      }
      return true;
    } catch { return false; }
  }
  static sanitize(urlString) {
    try {
      const url = new URL(urlString);
      const sensitive = ['token','key','session','auth','password','access_token','api_key','secret'];
      sensitive.forEach(p => url.searchParams.delete(p));
      return url.toString();
    } catch { return null; }
  }
}

class BradleyAPIClient {
  async analyzeMedia(url, mediaType, retries = 0) {
    if (!URLValidator.isValid(url)) throw new Error('Invalid URL');
    const sanitized = URLValidator.sanitize(url);
    if (state.isRateLimited()) throw new Error('Rate limited');

    const endpoint = mediaType === 'video'
      ? `${CONFIG.API_BASE}/detect_video_deepfake`
      : `${CONFIG.API_BASE}/detect_audio_deepfake`;

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), CONFIG.REQUEST_TIMEOUT);

    try {
      state.recordRequest();
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url_or_path: sanitized }),
        signal: controller.signal
      });
      clearTimeout(timeout);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const result = await response.json();
      if (!result || typeof result.is_deepfake !== 'boolean') throw new Error('Invalid response');
      return result;
    } catch (error) {
      clearTimeout(timeout);
      if (retries < CONFIG.MAX_RETRIES && error.name !== 'AbortError') {
        await new Promise(r => setTimeout(r, Math.pow(2, retries) * 1000));
        return this.analyzeMedia(url, mediaType, retries + 1);
      }
      throw error;
    }
  }
}

class MediaScanner {
  constructor() { this.apiClient = new BradleyAPIClient(); }
  scan() {
    if (!state.isEnabled || !state.hasConsent) return;
    const medias = [...document.querySelectorAll('video,audio')];
    medias.forEach(media => {
      if (media.dataset.bradleyScanned) return;
      const url = media.src || media.currentSrc;
      if (!url || url.startsWith('blob:') || url.startsWith('data:')) {
        media.dataset.bradleyScanned = 'skipped';
        return;
      }
      media.dataset.bradleyScanned = 'pending';
      new ScanIndicator(media).showScanning();
      state.scanQueue.push({ element: media, url });
    });
    this.processQueue();
  }
  async processQueue() {
    if (state.isScanning || state.scanQueue.length === 0) return;
    state.isScanning = true;
    while (state.scanQueue.length > 0) {
      const item = state.scanQueue.shift();
      await this.analyzeMedia(item);
    }
    state.isScanning = false;
  }
  async analyzeMedia(item) {
    const { element, url } = item;
    const mediaType = element.tagName.toLowerCase() === 'video' ? 'video' : 'audio';
    try {
      const result = await this.apiClient.analyzeMedia(url, mediaType);
      element.dataset.bradleyScanned = 'complete';
      new ScanIndicator(element).showResult(result);
      if (result.is_deepfake && result.confidence > CONFIG.CONFIDENCE_THRESHOLD) {
        new ThreatWarning(result).show();
      }
    } catch (error) {
      element.dataset.bradleyScanned = 'error';
      new ScanIndicator(element).showError(error.message);
    }
  }
}

class ScanIndicator {
  constructor(el) { this.el = el; }
  showScanning() { this.render('scanning', '⟐', 'Scanning...'); }
  showResult(r) {
    if (r.is_deepfake && r.confidence > CONFIG.CONFIDENCE_THRESHOLD) {
      this.render('threat', '⚠', `THREAT: ${Math.round(r.confidence*100)}%`);
    } else {
      this.render('safe', '✓', 'Verified');
      setTimeout(() => this.remove(), 3000);
    }
  }
  showError(msg) { this.render('error', '⚠', 'Scan failed'); }
  render(cls, icon, text) {
    let overlay = this.el.closest('.bradley-wrapper')?.querySelector('.bradley-indicator');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.className = 'bradley-indicator';
      const wrapper = document.createElement('div');
      wrapper.className = 'bradley-wrapper';
      wrapper.style.position = 'relative';
      this.el.parentNode.insertBefore(wrapper, this.el);
      wrapper.appendChild(this.el);
      wrapper.appendChild(overlay);
    }
    overlay.className = `bradley-indicator ${cls}`;
    overlay.innerHTML = `<div class="bradley-icon">${icon}</div><span>${text}</span>`;
  }
  remove() {
    const wrapper = this.el.closest('.bradley-wrapper');
    if (wrapper) wrapper.outerHTML = this.el.outerHTML;
  }
}

class ThreatWarning {
  constructor(result) { this.result = result; }
  show() {
    if (document.querySelector('.bradley-threat-overlay')) return;
    const overlay = document.createElement('div');
    overlay.className = 'bradley-threat-overlay';
    overlay.innerHTML = `
      <div class="bradley-warning-box">
        <div class="bradley-warning-header">
          <span class="bradley-logo">⟐ BRADLEY AI</span>
          <button class="bradley-close">×</button>
        </div>
        <div class="bradley-warning-content">
          <h2>⚠ DEEPFAKE DETECTED</h2>
          <p class="bradley-confidence">Confidence: ${Math.round(this.result.confidence * 100)}%</p>
          <p class="bradley-message">This media appears to be synthetically generated or manipulated.</p>
          <div class="bradley-actions">
            <button class="bradley-btn bradley-btn-primary" id="dismiss">Acknowledge</button>
            <button class="bradley-btn bradley-btn-secondary" id="report">Report</button>
          </div>
        </div>
      </div>`;
    document.body.appendChild(overlay);
    overlay.querySelector('.bradley-close').onclick = () => overlay.remove();
    overlay.querySelector('#dismiss').onclick = () => overlay.remove();
    overlay.querySelector('#report').onclick = () => {
      window.open(`${CONFIG.API_BASE}/report?url=${encodeURIComponent(location.href)}`, '_blank');
      overlay.remove();
    };
  }
}

class ConsentDialog {
  show(callback) {
    const dialog = document.createElement('div');
    dialog.className = 'bradley-consent-overlay';
    dialog.innerHTML = `...`; // (privacy policy dialog — full HTML from Claude)
    document.body.appendChild(dialog);
    dialog.querySelector('#consent-accept').onclick = () => { dialog.remove(); callback(true); };
    dialog.querySelector('#consent-decline').onclick = () => { dialog.remove(); callback(false); };
  }
}

let scanner;
state.initialize().then(() => {
  scanner = new MediaScanner();
  if (state.hasConsent && state.isEnabled) {
    scanner.scan();
    setInterval(() => scanner.scan(), CONFIG.SCAN_INTERVAL);
  }
  const observer = new MutationObserver(() => state.hasConsent && state.isEnabled && scanner.scan());
  observer.observe(document.body, { childList: true, subtree: true });
  console.log('[BRADLEY] Guardian active');
});
2. styles.css (Full Claude-Approved Styling)
CSS/* Bradley AI Extension — Secure & Accessible Styles */
.bradley-indicator {
  position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.85);
  color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px;
  z-index: 999999; display: flex; gap: 6px; pointer-events: none;
  transition: opacity 0.3s;
}
.bradley-scanning { background: rgba(59,130,246,0.9); }
.bradley-safe { background: rgba(34,197,94,0.9); }
.bradley-threat { background: rgba(239,68,68,0.95); pointer-events: auto; }
.bradley-error { background: rgba(245,158,11,0.9); }
.bradley-icon { font-size: 14px; }
@keyframes bradley-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
.bradley-scanning .bradley-icon { animation: bradley-spin 1s linear infinite; }

/* Threat Overlay + Consent Dialog — full Claude version here (copy from previous message) */
3. manifest.json (Final Secure V3)
JSON{
  "manifest_version": 3,
  "name": "Bradley AI - Deepfake Guardian",
  "version": "1.0.0",
  "description": "Real-time deepfake protection",
  "permissions": ["storage", "activeTab"],
  "host_permissions": ["https://bradleyai.replit.app/*"],
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'; connect-src 'self' https://bradleyai.replit.app"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"],
    "css": ["styles.css"],
    "run_at": "document_idle"
  }],
  "background": { "service_worker": "background.js" },
  "action": { "default_popup": "popup.html" },
  "icons": { "16": "icons/icon16.png", "48": "icons/icon48.png", "128": "icons/icon128.png" }
}